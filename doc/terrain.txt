                    地形
@remarks
 首先约定地形和内部的分割块都是正方形,称为Tile.
 每个正方形由其边上的顶点数表示,称<b>边点数</b>,
 且须存在整数n,使之等于2^n+1
@par
 对应场景的世界坐标系Terrain::WORLD_SPACE,
 地形本身存在局部坐标系Terrain::LOCAL_SPACE,
 其除了局部原点位于地形中心外,其它与世界坐标系相同.
 另外内部还使用两种变形的二维坐标,
 地形面的左下角为原点,向右为X,向上为Y,垂直于地形面的空间向量为Z轴.
 X,Y分量用于定位地形平面, Z轴则永远表示世界坐标系中的地形高度.
 - 用比例表示的逻辑坐标系Terrain::TERRAIN_SPACE,
   X,Y分量表示地形中比例位置,范围[0,1],
   可以表示地形中的任一平面位置(即使没有该顶点),但不太直观.
 - 用顶点序号表示的点坐标系Terrain::POINT_SPACE,
   X,Y分量表示地形中的顶点序号,范围[0,mSize-1],
   非常直观,但只能表示有顶点的平面位置,
   [X,Y]通常可由TerrainPoint表示,区域可由TerrainRect表示.
@par
 将地形(Terrain)按层次分割成块(Tile),
 例如,
     整个Terrain作为顶层Tile0,四等分后会增加4个Tile1,
     再将每个Tile1四等分后会增加16个Tile2, ...

 由此可见该分割等价于构造四叉树,自然的由
 四叉树结点(TerrainQuadTreeNode)表示,并按其树型层次组成.
@par
 Tile与树结点一一对应,且作为独立单元,是一个批次渲染的.
 实现时,Terrain中只需包含顶层树结点mQuadtree.
@par
 树结点可分为枝结点(non-leaf)和叶结点(leaf), 
 枝结点的等价条件为,
         对应Tile的边点数>maxBatchSize,
 即上述递归分割的终止条件为,
         边顶点数<=maxBatchSize
 假设地形边点数为terrainSize,则四叉树最大深度maxDepth为
         maxDepth = log2(terrainSize-1) - log2(maxBatchSize-1)
@par
 分割的过程同时也定义一系列层次精度表(LOD值越小,越精细)
 即使分割停止后的叶结点,也可进一步分割定义,直到
         边顶点数<=minBatchSize
 假设地形边点数为terrainSize,则LOD最大值maxLOD为
         maxLOD = log2(terrainSize-1) - log2(minBatchSize-1)
@par
 因为希望使用uint16的顶点索引值(最大只能定位0xFFFF=65535个顶点数),
 所以最大边顶点数只能是129x129=16641,因为下一级257x257=66049>65535无法用uint16索引.
 因此只能将顶点数据按129大小分组.
@par
 定义地形分辨率,是没有分组前的边点数,显然分辨率只针对顶点分布精细度的描述.
@par
 地形远离镜头时,结点处于高LOD层次,将使用更少的顶点渲染,可提高效率.
 但由于忽略一些顶点,使得其对应的真实高度被插值取代.
 由此导致的,真实高度与使用LOD后插值高度的差,称LOD高度差.
 最大LOD高度差,可以用来衡量该LOD的失真度.


我们将使用一个更多顶点数的地形来更详细的说明该问题.
 例如,存在如下地形
       size = 2049, min_batch = 33, max_batch = 65,
       max_depth = log2(2049-1) - log2(65-1) = 5
       max_lod = log2(2049-1) - log2(33-1) = 6
  步骤如下,
  - 分辨率必须适合当前最大索引集,
    故地形分辨率 resolution=2049,
    须分割 splits=(resolution-1)/(129-1)=16,
    沿树深度向上查找,其对应的深度为Depth4(因为2^4==16),
    说明Depth4-5可以共享顶点集合,且顶点集合的边点数
             size=(resolution-1)/splits+1=129,
    所以由Depth4层的16x16个结点各自创建,将是16x16个顶点数据集.
  - 接着地形resolution=257,splits=(resolution-1)/(129-1)=2段,
    沿树深度向上查找,其对应的深度为Depth1(因为2^1==2),
    说明Depth1-3可以共享顶点集合,且顶点集合的边点数
             size=(resolution-1)/splits+1=129,
    所以由Depth1层的2x2个结点各自创建,将是2x2个顶点数据集.
  - 接着地形resolution=33,splits=(resolution-1)/(129-1)=0段,
    强制创建,
             size=resolution=33,
    所以由Depth0层的1个结点创建,将是1个顶点数据集.
 @par
   内部细节如下,
      层次精度 结点深度   Tile信息  分辨率  索引集  顶点块          
      LOD 0    Depth 5    32 x 65    2049    2049   0-15  [129x16]  
      LOD 1    Depth 5    32 x 33    2049    1025   0-15  [129x16]  
      LOD 2    Depth 4    16 x 33    2049    513    0-15  [129x16]  
      LOD 3    Depth 3    8  x 33    513     257   16-17  [129x2]   
      LOD 4    Depth 2    4  x 33    513     129   16-17  [129x2]   
      LOD 5    Depth 1    2  x 33    129     65    16-17  [129x2]   
      LOD 6    Depth 0    1  x 33    129     33     18    [33x1]      
   注: 顶点块=边块序号 [边点数x个数]
   从上表可知,需要三层顶点数据集,才能满足条件.
 @par
  从顶点数量上看, 原顶点数为:2049^2=4198401
  分块后数为:(16 * 129)^2 + (2 * 129)^2 + 33^2 = 4327749
  约等于增加了3%的数量,但减少了渲染批次,还是值得的.
  而且当只渲染LOD3-6时,可以释放0-15顶点边块,这将节省98%的内存.
 
